--> Condicionales

Empezaremos con los condicionales. Los condicionales nos permiten decidir si un c√≥digo se ejecuta o no. 
Tambi√©n introducimos un nuevo tipo de datos primitivos: el booleano, que determina si un valor es falso o verdadero. 
Mediante un condicional (if) decidiremos si se ejecuta una parte de nuestro c√≥digo cuando se cumpla o no cierta condici√≥n.


--> Funciones que retornan valores

En esta clase seguiremos trabajando con condicionales para desglosar las funciones en funciones m√°s peque√±as que retornen
un valor.

Debemos de tener en cuenta que el n√∫mero 18 esta incluido dentro del rango de edad. Para ello utilizamos los s√≠mbolos >=.

Return detiene la ejecuci√≥n de una funci√≥n y devuelve el valor de esa funci√≥n.

Las variables definidas con const se comportan como las variables, excepto que no pueden ser reasignadas. Las constantes pueden
ser declaradas en may√∫sculas o min√∫sculas. Pero por convenci√≥n, para distinguirlas del resto de variables, se escribe todo en
mayusculas.

Para indinicar constantes se usa const. Es una buena practica nombrarla con mayusculas üòÑ

Ya casi no se usa el var, es mejor usar let, por que esta ultima respeta el scope de las funciones üòÑ


--> Arrow functions

En esta clase aprenderemos a utilizar Arrow Functions que permiten una nomenclatura m√°s corta para escribir expresiones de 
funciones. Este tipo de funciones deben definirse antes de ser utilizadas.

Al escribir las Arrow Functions no es necesario escribir la palabra function, la palabra return, ni las llaves.

Arrow Functions

JS permite asignar una funci√≥n a una variable. Se llama funci√≥n an√≥nima. Y se puede escribir de varias maneras:

const MAYORIA_DE_EDAD = 18

var esMayorDeEdad =function(persona){   	
	return persona.edad >= MAYORIA_DE_EDAD
}

Sacha prefiere declararla como ‚Äòconst‚Äô y no como ‚Äòvar‚Äô para definir que es una funci√≥n y no una variable:

    const esMayorDeEdad =function(persona){   	
        return persona.edad >= MAYORIA_DE_EDAD
    }

La palabra clave ‚Äòfunction‚Äô puede reemplazarse por un ‚Äò=>‚Äô despu√©s de persona y se convierte en un arrow function:

    const esMayorDeEdad = (persona) => {   	
        return persona.edad >= MAYORIA_DE_EDAD
    }

Se pueden seguir quitando caracteres.

    Cuando hay un s√≥lo par√°metro se pueden quitar los par√©ntesis.
    
    Si una funci√≥n s√≥lo retorna un valor se puede quitar el keyword ‚Äòreturn‚Äô y las llaves {}
    
        const esMayorDeEdad = persona => persona.edad >= MAYORIA_DE_EDAD

    Tambi√©n se puede desestructurar el par√°metro ya que s√≥lo nos interesa la edad. Hay que agregar par√©ntesis:

        const esMayorDeEdad = ({ edad }) => edad >= MAYORIA_DE_EDAD


--> Estructuras repetitivas: for

El bucle for, se utiliza para repetir una o m√°s instrucciones un determinado n√∫mero de veces.

Para escribir un bucle for se coloca la palabra for seguida de par√©ntesis y llaves.
Ej. for( ){ }. Dentro de los par√©ntesis ir√°n las condiciones para ejecutar el bucle, y dentro las llaves ir√°n las
instrucciones que se deben repetir.

En este ejemplo la variable i la utilizamos como contador.

Ciclo for : Nos permite realizar cierta tarea de manera repetitiva, es decir que podremos realizar una tarea una cierta cantidad
de veces.

Consiste de 3 partes:

    Inicial
    Condici√≥n
    Incremento

Dentro de las llaves se encuentra el cuerpo del ciclo for , que contiene las instrucciones que se repetir√°n mientras se cumpla la
condici√≥n.

Para saber cuantas veces queremos que se ejecute una condici√≥n utilizamos un contador .

Para incrementar / decrementar el contador utilizamos la parte final del for seg√∫n lo requiramos.

NOTA : Si introducimos un obj en una funci√≥n, sus propiedades ser√°n modificadas, ya que este es pasado por referencia. Si no
deseamos que eso suceda es necesario crear un nuevo objeto, desglosando el objeto original.


--> Estructuras repetitivas: while

While se ejecuta √∫nicamente mientras la condici√≥n que se est√° evaluando es verdadera.

En ocasiones nuestro c√≥digo puede fallar por errores de syntaxis o errores l√≥gicos. En caso de que quieras verificar tu c√≥digo,
debes utilizar un debugger. El c√≥digo se detiene cada vez que lee esta palabra.


--> Estructuras repetitivas: do-while

A diferencia de la instrucci√≥n while, un bucle do‚Ä¶while se ejecuta una vez antes de que se eval√∫e la expresi√≥n condicional.


--> Condicional m√∫ltiple: switch

Switch se utiliza para realizar diferentes acciones basadas en m√∫ltiples condiciones.

Prompt, muestra un cuadro de mensaje que le pide al usuario que ingrese alg√∫na informaci√≥n.

Break, sirve para que el browser se salte un bucle.